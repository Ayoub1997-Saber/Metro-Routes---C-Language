
/*************************************************** Projet du Langage C *******************************************/

/****************************************************
* 1- Nom du projet : Itinéraires de métro             *
* 2- Réalisé par :                                    *
*      Nom : Taihi                                    *
*      Prénom : Ayoub                                 *
*****************************************************/

#define _CRT_SECURE_NO_WARNINGS

#define _CRT_SECURE_NO_DEPRECATE

#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <time.h>                  /* destinÃ©e Ã  manipuler les trajets entre stations d'une ligne */                                  

#include <malloc.h>

#define TRUE 1

#define FALSE 0

#define LIGNES 14

#define STATIONS 1412 

/// I- dÃ©finition des structures : ///

        /* 1/ dÃ©finition de l'horaire */

typedef struct _SCHEDULE {

    int hour;

    int minute;

    int second;

} SCHEDULE;


/* 2/ manipulation des stations */

typedef struct _STATION {

    /* 2/ 1/ pour l'estimation du temps de trajet entre 2 stations */

                 /* - Utilisation d'une liste (organisation des stations selon l'ordre de passage) */


    int CurrentStation;                        // station actuelle //

    int NextStationTime;                       // mesure du temps vers la prochaine station //

    int PrevStationTime;                       // mesure du temps vers la prÃ©cÃ©dente station // 

    int path;                                  // unitÃ© pour la mesure du chemin minimal entre stations //                                   

    SCHEDULE firstTrain;                       // le premier train dans une ligne //   

    SCHEDULE lastTrain;                        // le dernier train dans une ligne //

    struct _STATION* head;                     // pointage vers d'autres stations depuis une station source //

    struct _STATION* pnext;                    // liaison avec la prochaine station //

    struct _STATION* pprev;                    // liaison avec la prÃ©cÃ©dente station //

    char* userStation;                        // entrÃ©e d'une station que l'utilisateur veut accÃ©der //

    int lineOfStation;                        // situation de la ligne d'une station //                    

} STATION;

/* 3/ manipulation des lignes */

typedef struct _LINE {

    int CurrentLine;                      // ligne actuelle //                                  

    STATION* enterLine;                   // indication pour entrer dans une des lignes //

    STATION* exitLine;                    // indication pour sortir dans une ligne // 

} LINE;

/// II- DÃ©finition des fonctions ///


             /* II-1- fonctions d'affichage et de calcul */


void timeOfItinerary(LINE line);                          // calcul du temps de trajet dans une des lignes de mÃ©tro //
void printStation(STATION* station);                      // affichage d'une des stations de mÃ©tro //
void printLine(LINE* line);                               // affichage d'une des lignes de mÃ©tro //  
int countStations(LINE* line);                            // comptage des stations d'une des ligne



           /* II-2- fonctionnalitÃ©s pour la manipulation des trajets (permettre Ã  l'utilisateur de trouver le meilleur chemin) */



int existStation(LINE line, char* name);                                         // test de l'existence d'une station dans une ligne (indiquer Ã  l'utilisateur la validitÃ© de la station qu'il veut la parvenir) //
int existLine(LINE* line);                                                      // test l'existence d'une ligne  
int addStation(STATION* interm, LINE* line);                                   // ajout d'une station dans une ligne (pour Ã©ventuellement construire un autre itinÃ©raire) //
STATION* deleteStationFromLine(char* name, STATION* station, LINE* line);      // suppression d'une station existante d'une ligne //
void correspondance(LINE* line);                                              // calcul de la correspondance //


// chargement et manipulation du fichier //


void loadStation(FILE* pstation, LINE* line, char* lineUser);                                    // chargement des stations d'une ligne issues du fichier "metro.csv" Â§Â§ 
void loadLine(FILE* pline, LINE line[]);                                                         // chargement des lignes issues du fichier "metro.csv" //                                         
LINE DepartureToArrival(FILE* file);                                                            // chargement de l'itinÃ©raire que doit suivre l'utilisateur //

/// III- Programme principal ///



int main(int argc, char** argv)
{

    /* crÃ©ation du "handle" pour manipuler les donnÃ©es du fichier "metro.csv" */

    FILE* pmetro = fopen("metro.csv", "r");

    if (!pmetro)

    {
        printf("impossible d'ouvrir le fichier!\n");
        exit(1);

    }

    /* ici mettre les fonctionnalitÃ©s pour manipuler les lignes et les stations de mÃ©tro issues du fichier "metro.csv" */
    /*puis fermeture du fichier */

    fclose(pmetro);
    return 0;
}





/// VI - dÃ©finitions des fonctions (on commence d'abord par les affichages du temps ) ///




void timeOfItinerary(LINE line)
{

    SCHEDULE durDirect, durInv;                                       // durDirect = durÃ©e du trajet aller -- durInv = durÃ©e du trajet retour //

    STATION* dir = line.enterLine;                                   // dir = direction (entrer dans une station d'une des ligne) //  

    /* mesure du trajet aller (calculer au fur et Ã  mesure le trajet entre 2 stations voisines jusqu'au terminal) */

    while (dir != line.exitLine)
    {

        durDirect.hour = (*dir).pnext->lastTrain.hour - dir->lastTrain.hour;
        durDirect.minute = (*dir).pnext->lastTrain.minute - dir->lastTrain.minute;
        durDirect.second = (*dir).pnext->lastTrain.second - dir->lastTrain.second;

        dir = (*dir).pnext;
    }

    dir = line.exitLine;                   // mÃ©moriser le pointeur qui pointe vers la station terminale pour faire l'opÃ©ration inverse //

    /* mesure du trajet retour (calculer au fur et Ã  mesure le trajet entre 2 stations voisines du terminal jusqu'Ã  l'entrÃ©e d'une ligne ) */

    while (dir != line.enterLine)
    {

        durInv.hour = (*dir).lastTrain.hour - dir->pprev->lastTrain.hour;
        durInv.minute = (*dir).lastTrain.minute - dir->pprev->lastTrain.minute;
        durInv.second = (*dir).lastTrain.second - dir->pprev->lastTrain.second;

        dir = (*dir).pprev;
    }


}









void printStation(STATION* station)
{
    printf("Nom de la station : %s\n", (*station).userStation);  // car il s'agit d'une station ou bien du dÃ©part ou bien de l'arrivÃ©e //
    printf("Trajet parcouru : %d\n", (*station).path);
}

void printLine(LINE* line)
{

    STATION* stationLine;                            // tous les stations d'une seule ligne //

    stationLine = (*line).enterLine;                 // accÃ¨s Ã  une ligne particuliÃ¨re (passÃ©e en argument de printLine) //

    printf("The Parisian metro line :\n");


    if (existLine(line))
    {

        while (stationLine != line->exitLine) // condition d'arrÃªt qui correspond Ã  la fin d'une ligne (sortie) //
        {

            printStation(stationLine);
            stationLine = (*stationLine).pnext;

        }

        // affichage de la derniÃ¨re station (qui n'Ã©tait pas incluse dans la boucle) et sortie d'une ligne //

        printStation((*line).exitLine);

    }

    else

        printf("Sorry, there is an error of entering metro!\n");
}











int countStations(LINE* line)
{

    STATION* stations;
    stations = (*line).enterLine;
    int number_of_stations = 0;

    do {

        number_of_stations = number_of_stations + 1;

        stations = (*stations).pnext;

    } while (stations != NULL);                          // jusqu'Ã  la derniÃ¨re station d'une des lignes entrÃ©es en argument de la fonction 

    return number_of_stations;
}











int existStation(LINE line, char* name)
{

    int exist = TRUE;                                                          // test de l'existence d'une station dans une des lignes passÃ©e en argument de la foction // 

    STATION* station = line.enterLine;

    do {
        for (int i = 0; (*station).userStation[i] == name[i] && (*station).userStation[i] == '\0'; i++)
            if (!((*station).userStation[i] > name[i]) && !((*station).userStation[i] < name[i]))                                 // test du nom entrÃ© par l'utilisateur (passÃ© en argument de la foction) s'il est valide // 

                return exist;

            else

                return EXIT_FAILURE;

        station = (*station).pnext;

    } while ((*station).pnext != NULL);

    return EXIT_SUCCESS;
}









int existLine(LINE* line)
{

    int exist = TRUE;

    if ((*line).enterLine != NULL || (*line).exitLine != NULL)

        return exist;

    else

        return EXIT_FAILURE;

}








int addStation(STATION* station, LINE* line)
{

    STATION* interm = (*line).enterLine;                            /* "pointeur" intermÃ©diaire (qui sert Ã  rÃ©server de l'emplacement mÃ©moire Ã  une nouvelle station) */
    interm = (*line).enterLine;                                     /* intÃ©grer ce pointeur Ã  l'entrÃ©e d'une ligne */

      /* l'ajout se fait au cas par cas */

    do {

        if (interm == (*line).enterLine)                     /* 1- Si l'ajout se fait au dÃ©but d'une ligne */
        {

            (*interm).pprev = station;                                  /* le pointeur habituel d'une station devient le prÃ©cÃ©dent */

            (*line).enterLine = station;                                /* "redÃ©finir" l'entrÃ©e de la ligne (intÃ¨grer le pointeur qui relie la nouvelle station Ã  l'entrÃ©e de la ligne) */

            (*station).pnext = interm;                                  /* permuter le pointeur de "station" par le pointeur intermÃ©diaire pour rÃ©server de l'emplacement mÃ©moire */

        }

        else                                                 /* 2- Si l'ajout se fait au milieu ou Ã  la fin de la ligne */
        {

            (*interm).pprev = station;                                /* mÃªme explication que 1- */

            (*station).pnext = station;                               /* pour rÃ©server l'emplacement mÃ©moire Ã  la nouvelle station dans la ligne */
                                                                        // mise Ã  jour des 2 pointeurs //
            (*interm).pprev = station;                                /* "redÃ©finir" le pointeur de la station vers la nouvelle station (qui remplace la 2Ã¨me ligne de 1- car on est au milieu/fin d'une ligne) */

            (*station).pnext = interm;                                /* mÃªme explication que 1- */
        }

        interm = (*interm).pnext;                            /* 3- Mise Ã  jour du pointeur intermÃ©diaire (pour faire la mise Ã  jour de la nouvelle ligne) */
    } while (interm != NULL);                                /* sortie de la boucle et fin de l'opÃ©ration */

    interm = (*line).exitLine;                                        /* Mise Ã  jour Ã©galement du pointeur de la sortie d'une ligne (qui n'Ã©tait pas inclus dans la boucle) */


}










STATION* deleteStationFromLine(char* name, STATION* station, LINE* line)        // suppression d'une station existante d'une ligne //
{

    station = NULL;                                                             // suppression d'une station dans une ligne //

    if (existLine(line))
    {

        /* 1- le cas oÃ¹ la station se trouve au dÃ©but d'une ligne */

        if ((*line).enterLine->userStation == name)

        {

            station = (*line).enterLine;                                           // suppression de la station d'entrÃ©e d'une ligne // 

            (*line).enterLine = (*line).enterLine->pnext;                          // mise Ã  jour du pointeur de la nouvelle entrÃ©e d'une ligne qui se trouve aprÃ¨s l'ancienne station d'entrÃ©e // 

            (*line).enterLine->pprev = NULL;                                      // la nouvelle station d'entrÃ©e ne contient pas le pointeur prÃ©cÃ©dent //

        }


        /* 2- le cas oÃ¹ la station se trouve Ã  la fin d'une ligne */

        else if ((*line).exitLine->userStation == name)

        {

            station = (*line).exitLine;                                         // suppression de la station de sortie d'une ligne //

            (*line).exitLine = (*line).exitLine->pprev;                        // mise Ã  jour du pointeur de la nouvelle sortie d'une ligne qui se trouve avant l'ancienne station de sortie //

            (*line).exitLine->pnext = NULL;                                    // la nouvelle station de sortie ne contient pas le pointeur suivant //

        }

        /* 3- le cas oÃ¹ la station se trouve au milieu d'une ligne */

        else

        {

            station = (*line).enterLine;

            (*line).enterLine = (*line).enterLine->pnext;                      // initialisation du pointeur nul vers la station suivante (et faire le test Ã  partir de la 2Ã¨me station d'une ligne) // 

            do {

                if ((*line).enterLine->userStation == name)
                {

                    station = (*station).pnext;                                    // tous les cas oÃ¹ une station peut Ãªtre au milieu  

                    (*station).pprev = (*station).pnext;                           // pour remplacer la station supprimÃ©e par la station qui la prÃ©cÃ¨de // 

                    (*station).pnext->pnext = (*station).pnext;                    // mise Ã  jour du pointeur suivant de la station qui remplace la station supprimÃ©e //

                    (*station).pnext->pprev = (*station).pprev;                    // mise Ã  jour du pointeur prÃ©cÃ©dent de la station qui remplace la station supprimÃ©e //

                }

            } while (station != (*line).exitLine);                                // mise Ã  jour des pointeurs de toutes les stations (le pointeur courant d'une station devient le prochain mis Ã  part le pointeur qui dÃ©signe la sortie de la ligne) //



        }
    }

    else
    {

        printf("Sorry, there is an error of entering metro line!\n");

    }
    return station;
}












void correspondance(LINE* line)
{

    STATION* station = (*line).enterLine;

    do {

        if ((*line).enterLine != (*line).enterLine->pnext)
        {

            printLine(line);                                                                 // suivre l'itinÃ©raire qui ne comporte pas la correspondance //
            station = (*station).pnext;                                                        // tester jusqu'Ã  l'arrivÃ©e Ã  une destination //

        }


    } while ((*station).pnext != NULL);

}












void loadStation(FILE* pstation, LINE* line, char* lineUser)
{
    //caractÃ¨res de dÃ©limitation//

    char* dieses[17] = { "####1","####2","####3","####3bis","####4","####5","####6","####7","####7bis","####8","####9","####10","####11","####12","####13" };

    char colon[2] = ":";

    // temps de trajet //

    double hourFile;

    /* 1- Allocation dynamique pour extraire les champs de valeurs du fichier ainsi que le nom entrÃ© par l'utilisateur */

    STATION* station = (STATION*)calloc(LIGNES, sizeof(STATION));              // allouer dynamiquement les donnÃ©es de chaque station //

    int information;

    do {

        STATION* departure = (STATION*)calloc(1, sizeof(STATION));         // allouer dynamiquement la station de dÃ©part pour suivre son chemin // 

        information = 0;                                                   // chaque champ a son propre information

              /* 1-1 Extraire chaque champ du fichier "metro.csv"  */

        char* nameUser = (char*)calloc(LIGNES, sizeof(char));           // allouer dynamiquement le nom de la station entrÃ©e par l'utilisateur //   

        fgets(nameUser, LIGNES, pstation);                              // lire le contenu de chaque ligne du fichier "metro.csv" // 

        char* pinfo = strtok(nameUser, colon);                          // identifier toutes les informations sÃ©parÃ©es par ":" et donner la signification Ã  chacune : 

        while (pinfo != NULL)
        {

            switch (information)

            {

            case 0:                                                 // cas de dÃ©tection de la ligne //

                (*departure).lineOfStation = atoi(pinfo);            // transformer la chaÃ®ne de caractÃ¨re qui dÃ©signe le numÃ©ro de la ligne en une valeur numÃ©rique //
                break;

            case 1:                     // cas de dÃ©termination du sens de trajet (a ou b) //

                while (departure != NULL)
                {
                    if (pinfo == "a")

                        departure = (*departure).pnext;                         // rÃ©cupÃ©rer le sens du trajet aller //

                    else if (pinfo == "b")

                        departure = (*departure).pprev;                         // rÃ©cupÃ©rer le sens du trajet retour //
                }
                break;

            case 2:                     // cas de la dÃ©termination de la station //

                (*departure).userStation = (char*)calloc(strlen(pinfo) + 1, sizeof(char));              // allouer dynamiquement le nom entrÃ© par l'utilisateur //

            case 3:
                break;
            case 4:
                break;

            case 5:                     // cas de la dÃ©termination de l'heure de dÃ©part du 1er mÃ©tro //

                hourFile = atof(pinfo);                                                        // convertir l'heure de dÃ©part en une virgule flottante // 

                (*departure).firstTrain.hour = (int)hourFile;                                  // stocker chaque heure pour les manipuler dans la suite (stocker des entiers de la virgule flottante car les mantisses correspondent aux minutes) //

                break;

            case 6:                    // cas de la dÃ©termination de l'heure de passage du dernier mÃ©tro //

                hourFile = atof(pinfo);

                (*departure).lastTrain.hour = (int)hourFile;

                break;

            default:

                printf("error of entering metro!\n");


            }

            information++;                                              // passer par tous les cas // 

            pinfo = strtok(NULL, colon);                                   // aprÃ¨s le passage par chaque cas, on initialise "pinfo" par 0 (pour ne pas garder les informations prÃ©cÃ©dentes) // 
        }
    } while (information <= 6);

    /* 2- DÃ©tection de la ligne oÃ¹ se trouve la station */

    int i = 0;
    while (dieses[i] != '\0')
        if ((&lineUser[i]) == dieses[i])
        {
            (*line).CurrentLine = (i + 1);
            i++;
        }

    /***************************
for (int i = 1; i < LIGNES; i++)

if (lineUser == "####1" && i == 1)                                          (*line).CurrentLine = i;

else if (lineUser == "####2" && i == 2)                                     (*line).CurrentLine = i;

else if ((lineUser == "####3" || lineUser == "####3bis") && i == 3 )        (*line).CurrentLine = i;

else if (lineUser == "####4" && i == 4)                                     (*line).CurrentLine = i;

else if (lineUser == "####5" && i == 5)                                     (*line).CurrentLine = i;

else if (lineUser == "####6" && i == 6)                                     (*line).CurrentLine = i;

else if ((lineUser == "####7" || lineUser == "####7bis") && i == 7)         (*line).CurrentLine = i;

else if (lineUser == "####8" && i == 8)                                     (*line).CurrentLine = i;

else if (lineUser == "####9" && i == 9)                                     (*line).CurrentLine = i;

else if (lineUser == "####10" && i == 10)                                   (*line).CurrentLine = i;

else if (lineUser == "####11" && i == 11)                                   (*line).CurrentLine = i;

else if (lineUser == "####12" && i == 12)                                   (*line).CurrentLine = i;

else if (lineUser == "####13" && i == 13)                                   (*line).CurrentLine = i;

else                                                                        (*line).CurrentLine = i;


*************************/
}





































void loadLine(FILE* pline, LINE line[])
{

    char* dieses[16] = { "####1","####2","####3","####3bis","####4","####5","####6","####7","####7bis","####8","####9","####10","####11","####12","####13" };

    int i;

    for (i = 1; i <= 16; i++)

        while (dieses[i] != '\0')
        {

            loadStation(pline, &line[i], dieses[i]);                                              /* charger toutes les stations la ligne */

        }

}




















LINE DepartureToArrival(FILE* file)
{

    LINE line = { 0,NULL,NULL };

    loadLine(file, &line);

    char* diesesD[16] = { "####1","####2","####3","####3bis","####4","####5","####6","####7","####7bis","####8","####9","####10","####11","####12","####13" };

    int i;
    for (i = 1; i <= 16; i++)

        while (diesesD[i] != '\0')
        {

            loadStation(file, &line, diesesD[i]);                                              /* charger toutes les stations la ligne de dÃ©part */

        }


    char* diesesA[16] = { "####1","####2","####3","####3bis","####4","####5","####6","####7","####7bis","####8","####9","####10","####11","####12","####13" };

    for (i = 1; i <= 16; i++)

        while (diesesA[i] != '\0')
        {

            loadStation(file, &line, diesesA[i]);                                              /* charger toutes les stations la ligne d'arrivÃ©e */

        }

    STATION* departure = line.enterLine;
    STATION* arrival = line.exitLine;

    // construire un itinÃ©raire (pas forcÃ©ment le plus court) //

    while (departure != NULL)
    {
        do {

            if ((*departure).userStation == (*arrival).userStation)
                deleteStationFromLine((*arrival).userStation, arrival, &line);                                   /* si au pire l'utilisateur rentre une station la mÃªme que celle de l'entrÃ©e on la supprime */

            arrival = (*arrival).pprev;  /* mise Ã  jour du pointeur de l'arrivÃ©e prÃ©cÃ©dent aprÃ¨s suppression de sa station */

        } while (arrival != line.enterLine);                                            // parcourir tous le chemin jusqu'Ã  l'arrivÃ©e Ã  l'entrÃ©e de la ligne //

        arrival = line.exitLine;                                                           // mise Ã  jour du nouveau pointeur de l'arrivÃ©e 

        departure = (*departure).pnext;                                                    // mise Ã  jour jusqu'Ã  l'arrivÃ©e de tous les pointeurs qui prÃ©cÃ¨dent la station de dÃ©part 
    }

    return line;                                                                           // avoir toute la "carte" (itinÃ©raire) du dÃ©part jusqu'Ã  l'arrivÃ©e //
}